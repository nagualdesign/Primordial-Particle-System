<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Primordial Particle System</title>
<meta name="description" content="Based on the YouTube video, 'How life emerges from a simple particle motion law: Introducing the Primordial Particle System'" />
<meta name="author" content="nagualdesign & planet 11 games" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet">

<script>
// For more information visit: https://www.youtube.com/watch?v=makaJpLvbow
// This video focuses primarily on specific values of alpha, beta, v and r
// It goes on to show the effects of altering the values of alpha and beta
// Here you can also explore various values of gamma, the ratio of v and r
//    Gamma (γ) = speed of particles (v) / radius of neighbourhoods (r)
// Particle behaviour is only dependent on values of alpha, beta and gamma
// Any particular combination of alpha, beta and gamma is called a species
// Differences in particle density will affect a species overall behaviour
// The simulation is scale invariant and works the same at any screen size
// You can also increase or decrease particle density by zooming in or out

// Global variables
const pi=Math.PI, tau=2*pi;                     // Used extensively
var canvas, context;                            // HTML canvas DOM elements
var p, a, b, g, caption, demo=0;                // Particle parameters
var vw, vh, z, dpr, cw, ch;                     // Viewport and HTML canvas
var r, r2, v, sr, sr2, vwsr4, vhsr4, srdrp;     // Used extensively
var count, elapsed, time, dist=0, paused=true;  // Simulation parameters
var hist, hl=0;                                 // Analytics

// Default settings
var n=600;  // Number of particles (100 to 10,000)
var d=8.0;  // Particle density at 100% zoom (1.0 to 10.0)
var s=0.1;  // Visible radius of particles relative to r (0.01 to 1.00)
var o=1.0;  // Background opacity (1.0 to 0.1)
var f=25;   // Maximum frames rate (10 to 100)

// Preset values of alpha, beta and gamma
var preset=[[10,10,0.2,20,0.5,s,1,5,0,
    '<nobr>These are called Primordial Particles.</nobr> '+
    '<nobr>They sense and react to particles nearby.</nobr> '+
    '<nobr>Their behaviour follows 3 simple rules:</nobr><br />'+
    '<nobr class="break">At each step they turn by a fixed amount,</nobr> '+
    '<nobr>then turn away or towards their neighbours,</nobr> '+
    '<nobr>then move forwards by a fixed amount.</nobr>'],
  [180,17,0.134,n,d,s,o,15,0,'Some species exhibit cell-like behaviour'],
  [92,-15,0.125,1000,d,s,0.6,f,0,'Internal contrarotation'],
  [5,31,0.166,n,2,s,0.1,f,0,'Sprites'],
  [-23,2,0.166,n,10,s,0.6,f,0,'Donuts'],
  [114,-4,0.166,800,d,s,0.4,f,0,'Goblins'],
  [173,-8,0.200,1000,d,s,0.1,f,0,'Puff balls'],
  [22,-29,0.125,400,d,s,0.1,f,0,'Lava lamp'],
  [174,15,0.200,1000,10,s,0.6,f,0,'Thick cell walls'],
  [-90,-90,0.333,1000,2,s,0.1,f,0,'Liquid crystal'],
  [-20,-25,0.143,1000,d,s,0.6,f,0,'Gradual evolution'],
  [146,8,0.125,1000,20,0.075,0.6,f,0,'Thermophiles'],
  [117,-4,0.143,1000,18,0.075,0.6,f,0,'Amoebas merging and evolving'],
  [35,-5,0.134,1000,32,0.075,0.6,f,0,'Extreme density'],
  [-70,5,0.13,1600,d,0.075,0.5,f,1,'Nascent organelles'],
  [-177,3,0.27,1600,10,0.075,0.6,f,1,'Shockwave'],
  [-69,-1,0.205,2000,d,0.05,0.3,f,1,'Rainbow juice'],
  [42,9,0.275,1500,5,0.075,0.6,f,1,'Cell nucleus'],
  [0,13,0.2,2000,10,0.075,0.2,f,0,'Exchanging particles'],
  [139,-28,0.1,100,2,0.05,0.1,100,1,'Silly string']];
  
// Run simulation
function initialize() {
  // Load values of alpha, beta and gamma
  let url=window.location.search.substring(1).split(",");                           // Check URL for settings
  if (!url[0]) species(0);                                                          // Default species
  else if (url.length==1) { demo=url; species(url); }                               // Load species presets
  else if (url.length>=3) species(url[0],url[1],url[2]);                            // Set species parameters
  if (url.length>3) n=url[3], d=url[4], s=url[5], o=url[6], f=url[7], dist=url[8];  // Environmental controls
  
  // Setup HTML canvas
  canvas=document.getElementById("canvas");
  context=canvas.getContext("2d");
  refresh();
}

// Set values of alpha, beta and gamma
function species(abg) {
  caption='&emsp;';
  if (arguments.length==0) {
    // Randomize values (360 × 120 × 100 = 4,320,000 possible values!)
    a=Math.round(Math.random()*360)-180;  // Alpha (-180° to +180°)
    b=Math.round(Math.random()*180)-90;   // Beta (-90° to +90°)
    g=Math.ceil(Math.random()*100)/200;   // Gamma (0.005 to 0.500)
  } else if (arguments.length==1) {
    // Use preset values
    let pre=preset[abg];
    a=pre[0], b=pre[1], g=pre[2];
    n=pre[3], d=pre[4], s=pre[5], o=pre[6], f=pre[7];
    dist=pre[8], caption=pre[9];
  } else {
    // Use selected values
    a=arguments[0], b=arguments[1], g=arguments[2];
  }
  
  // Convert values to radians!
  a=(a/360)*tau, b=(b/360)*tau;
  
  // Update user interface
  sliders(); showabg();
}

// Apply settings to control sliders
function sliders() {
  document.getElementById("alpha").value=Math.round((a/pi)*180);
  document.getElementById("beta").value=Math.round((b/pi)*180);
  document.getElementById("gamma").value=g;
  document.getElementById("number").value=n;
  document.getElementById("num").innerHTML=n;
  document.getElementById("density").value=d;
  document.getElementById("den").innerHTML=Math.round(d*z*z*100);
  document.getElementById("size").value=s;
  document.getElementById("trails").value=1-o;
  document.getElementById("framerate").value=f;
  document.getElementById("rate").innerHTML=f;
}

// Display current settings
function showabg() {
  document.getElementById("info").innerHTML=caption;
  let sHTML='α&thinsp;'+Math.round((a/pi)*180)+'°&emsp;β&thinsp;'+Math.round((b/pi)*180)+'°&emsp;γ&thinsp;'+g;
  document.getElementById("settings").innerHTML=sHTML;
}

// Begin new simulation
function refresh(rd) {
  if (!paused) playPause();
  if (rd!==undefined) dist=rd;
  count=0, elapsed=0;
  scale(); setvr(); sliders();
  if (n>10000) p=new Array(eval(n));
  else p=new Array(10000);
  for (i=0; i<p.length; i++) p[i]=new Particle();
  playPause();
}

// Play/pause simulation
function playPause() {
  if (paused) {
    // Play simulation
    paused=false;
    time=new Date().getTime();
    document.getElementById("controls").style.right='-45vh';
    run=setInterval(step,1000/f);
  } else {
    // Pause simulation
    paused=true;
    elapsed+=(new Date().getTime()-time);
    document.getElementById("controls").style.right='0';
    window.clearTimeout(run);
    histogram();
  }
}

function Particle() {
  if (dist==0) {
    // Set uniform distribution
    this.x=Math.random()*vw;
    this.y=Math.random()*vh;
  } else if (dist==1) {
    // Set centre-weighted distribution
    let mx=Math.max(0,(vw-vh)/2), my=Math.max(0,(vh-vw)/2), min=Math.min(vw,vh);
    this.x=mx+((Math.random()+Math.random()+Math.random())/3)*min;
    this.y=my+((Math.random()+Math.random()+Math.random())/3)*min;
  }
  this.phi=Math.random()*tau;  // Set random orientation
  this.N=0;                    // Number of neighbours
  this.L=0;                    // Neighbours on left
  this.R=0;                    // Neighbours on right
}

// Set scale of viewport, canvas and particles
function scale() {
  // Screen dimensions
  vw=window.innerWidth, vh=window.innerHeight;     // Viewport dimensions (CSS pixels)
  z=Math.round(((window.outerWidth-8)/vw)*20)/20;  // Browser zoom level (desktop)
  dpr=Math.round(window.devicePixelRatio*20)/20;   // Device Pixel Ratio (mobile)
  cw=(vw*dpr), ch=(vh*dpr);                        // HTML canvas dimensions
  
  // Set display size (CSS pixels)
  canvas.style.width=vw+'px';
  canvas.style.height=vh+'px';
  
  // Set actual size in memory (scaled to DPR)
  canvas.width=cw;
  canvas.height=ch;
  
  // Normalize coordinate system to use CSS pixels
  context.scale(dpr,dpr);
  
  console.log('Viewport: vw='+vw+' vh='+vh+'\nScaling: z='+z+' dpr='+dpr+'\nCanvas: cw='+cw+' ch='+ch);
}

// Calculate r and v based on viewport dimensions, density and gamma
function setvr() {
  r=Math.sqrt((vw*vh*z*z*d)/(n*pi)), r2=r*r;                                   // Radius of neighbourhoods (r)
  v=g*r;                                                                       // Speed of particles
  sr=s*r, sr2=sr*2, sr4=sr*4, vwsr4=(sr*4)+vw, vhsr4=(sr*4)+vh, srdpr=sr*dpr;  // Scale visible size of particles
  console.log('r='+r+'\nv='+v+'\ns='+sr+'\ng='+g);                             // Display values in the console
}

// Advance simulation by one step (this function is called f times per second)
function step() {
  count++; hist=new Array(); hl-=0.5*(hl/f);
  let gridCellSize=r;
  let xCells=Math.ceil(vwsr4/gridCellSize)+1;
  let yCells=Math.ceil(vhsr4/gridCellSize)+1;
  
  // Destroy and remake grid each frame
  let grid=new Array(xCells);
  for (i=0;i<xCells;i++) {
    grid[i]=new Array(yCells);
    for (ii=0;ii<yCells;ii++) grid[i][ii]=new Array;
  }
  
  // Insert every particles index into a grid cell
  for (i=0; i<n; i++) grid[Math.floor((p[i].x+sr4)/gridCellSize)][Math.floor((p[i].y+sr4)/gridCellSize)].push(i);
  
  // Calculate and apply changes in orientation
  for (xg=0; xg<xCells; xg++) {							                            // Step through the grid cells (left to right)
    for (yg=0; yg<yCells; yg++) {                                       // Step through the grid cells (top to bottom)
      for (gp=0; gp<grid[xg][yg].length; gp++) {		                    // Step through the particles in each grid
        let i=grid[xg][yg][gp];                                         // Now we have a particle index and we're already in the right grid
        for (xc=Math.max(0,xg-1); xc<Math.min(xg+2, xCells); xc++) {    // Iterate through the 8 neighbour cells (left to right)
          for (yc=Math.max(0,yg-1); yc<Math.min(yg+2, yCells); yc++) {  // Iterate through the 8 neighbour cells (top to bottom)
            for (jp=0; jp<grid[xc][yc].length; jp++) {                  // Iterate through the particles in each cell			
              let j=grid[xc][yc][jp];                                   // Finally we have both i & j
              if (i<j) {                                                // Still not gonna check it twice
                let sX=p[j].x-p[i].x;                                   // Calculate x-axis separation
                if (Math.abs(sX)<r) {                                   // Only if x-axis separation is less than r
                  let sY=p[j].y-p[i].y;                                 // Calculate y-axis separation
                  if (Math.abs(sY)<r) {                                 // Only if y-axis separation is also less than r
                    let sD=(sX*sX)+(sY*sY);                             // Calculate the square of the separation distance
                    if (sD<r2) {                                        // Only if separation distance is also less than r
                      p[i].N++, p[j].N++;                               // Increase total neighbour counts
                      let sA=scope(Math.atan2(sY,sX),tau);              // Calculate separation angle using trigonometry
                      if (scope(sA-p[i].phi,tau)<pi) p[i].R++;          // Particle j is to the right of i
                      else p[i].L++;                                    // Particle j is to the left of i
                      if (scope(sA-p[j].phi,tau)>pi) p[j].R++;          // Particle i is to the right of j
                      else p[j].L++;                                    // Particle i is to the left of j
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Clear HTML canvas (or leave trails)
  context.fillStyle='rgba(0,0,0,'+o+')';
  context.fillRect(0,0,vw,vh);
  
  // Position particles
  for (i=0; i<n; i++) {
    if (hist[p[i].N]===undefined) hist[p[i].N]=0;
    else hist[p[i].N]++;
    
    // Select HSL based on number of neighbours
    let hue=(p[i].N*7)+90;
    hsl='hsl('+hue+',100%,50%)';
    
    // Draw particle on HTML canvas
    if (srdpr>2) {
      // Draw a circle
      context.beginPath();
      context.arc(p[i].x,p[i].y,sr,0,tau);
      context.fillStyle=hsl;
      context.fill();
      context.closePath();
    } else {
      // Draw a small square
      context.fillStyle=hsl;
      context.fillRect(p[i].x-sr,p[i].y-sr,sr2,sr2);
    }
    
    // Draw radius, orientation and gamma (r, phi and g)
    if ((n<=500) && (f<=15)) {
      context.beginPath();
      context.moveTo(p[i].x,p[i].y);
      context.lineTo(p[i].x+(v*Math.cos(p[i].phi)),p[i].y+(v*Math.sin(p[i].phi)));
      context.strokeStyle='#666';
      context.stroke();
      context.closePath();
      context.beginPath();
      context.arc(p[i].x,p[i].y,r,0,tau);
      context.strokeStyle='rgba(255,255,255,'+(50/(n*f))+')';
      context.stroke();
      context.closePath();
    }
    
    // delta_phi = alpha + beta × N × sign(R - L)
    let delta_phi=a+(b*p[i].N*Math.sign(p[i].R-p[i].L));
    
    // Turn right delta_phi
    p[i].phi=scope(p[i].phi+delta_phi,tau);
    
    // Move forward v
    p[i].x+=(v*Math.cos(p[i].phi));
    p[i].y+=(v*Math.sin(p[i].phi));
    
    // Wrap screen edges, Pac-Man style
    p[i].x=scope(p[i].x+sr2,vwsr4)-sr2;
    p[i].y=scope(p[i].y+sr2,vhsr4)-sr2;
    
    // Reset values of N, L and R
    p[i].N=0, p[i].L=0, p[i].R=0;
  }
  
  // Analytics
  // framespersecond();
  // histogram();
}

function framespersecond() {
  let ms=elapsed+(new Date().getTime()-time);
  let fps=Math.round(((count*1000)/ms)*10)/10;
  console.log('Method '+method+':\n'+count+' cycles, '+ms+'ms ('+fps+'fps)');
}

function histogram() {
  if (eval(hist.length)>hl) hl=hist.length;
  let col=vw/hl, scale=10, ave=0;
  for (i=0; i<hl; i++) if (hist[i]>0) {
    ave=ave+(hist[i]*i);
    let bar=Math.sqrt(hist[i])*scale;
    context.fillStyle='hsla('+((i*7)+90)+',100%,25%,'+(50*o)+'%)';
    context.fillRect(i*col,vh-bar,col,bar);
  }
  ave=Math.round((ave/n)*100)/100;
  console.log('Density (d):'+Math.round(d*z*z*100)/100+'\nAverage (N):'+ave);
}

// Ensure values are between 0 and max
function scope(val,max) {
  if (val>max) val=val%max;
  else if (val<0) val=max+(val%max);
  return val;
}

// Cycle through species presets
function next() {
  demo++;
  if (demo==preset.length) demo=0;
  species(demo);
}

// Apply control panel settings (user inputs)
function change(id,value) {
  if (id=='alpha') a=(value/180)*pi;
  else if (id=='beta') b=(value/180)*pi;
  else if (id=='gamma') { g=value, v=g*r; }
  else if (id=='number') { n=value; setvr(); document.getElementById("num").innerHTML=n; }
  else if (id=='density') { d=value; scale; setvr(); document.getElementById("den").innerHTML=Math.round(d*z*z*100); }
  else if (id=='trails') o=1-value;
  else if (id=='size') s=value, sr=s*r, sr2=sr*2, sr4=sr*4, vwsr4=vw+sr4, vhsr4=vh+sr4, srdpr=sr*dpr;
  else if (id=='framerate') { f=value; document.getElementById("rate").innerHTML=f; }
  if ((id=='alpha') || (id=='beta') || (id=='gamma')) { caption='&emsp;'; showabg(); }
  if (paused) step();
  else if (id=='framerate') { window.clearTimeout(run); run=setInterval(step,1000/f); }
}

// Open a new page using current settings
function link(env) {
  let href=window.location;
  href=href.protocol+href.pathname+href.hostname+'?';
  if (caption!='&emsp;') href+=demo;
  else {
    href+=Math.round((a/pi)*180)+','+Math.round((b/pi)*180)+','+g;
    if (env) href+=','+n+','+d+','+s+','+o+','+f+','+dist;
  }
  window.open(href,'_self');
}
</script>

<style>
* { border:0;  margin:0; padding:0; vertical-align:baseline; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box; }
body { background:#000; font-family:Roboto; font-weight:200; text-shadow:0 0.1vh 0.2vh #000, 0 0.1vh 0.2vh #000; overflow:hidden; }
nobr { white-space:nowrap; display:inline-block; }
#info { cursor:pointer; font-size:calc(7vmin - 2.3vw); line-height:1.75em; color:#AAA; padding:3vh; position:fixed; top:0vmin; left:0vmin; z-index:2; }
.break { margin-top:calc(4.5vh - 4.5vmin); }
#settings { cursor:pointer; font-size:2.5vh; color:#AAA; padding:3vh; position:fixed; bottom:0vmin; left:0vmin; z-index:3; }
#controls { padding:4.5vh 0 1.5vh 0; width:45.15vh; height:100vh; background:rgba(48,48,48,0.9); border-left:0.1vh solid #000; text-align:center; position:absolute; top:0; right:-45vh; z-index:2; transition:right 0.25s; }
#controls:hover { right:0 !important; }
#controls h1 { font-size:3vh; font-weight:normal; color:#FFF; line-height:1; cursor:pointer; }
#controls h2 { margin:2.5vh 0 1vh 0; font-size:2.5vh; font-weight:normal; color:#FFF; cursor:pointer; }
#controls p { margin-bottom:3vmin; font-size:1.8vh; color:#CCC; line-height:1.5; }
#controls p a { color:#EEE; text-decoration:none; }
#controls p a:hover { color:#FFF; }
input[type=range] { margin:0.75vh 0; width:34vh; height:2vh; cursor:pointer; }
input[type=button] { margin:0.5vh 0; width:16vh; height:3vh; font-size:1.8vh; cursor:pointer; }
</style>

</head>
<body onLoad="initialize();" onResize="refresh();">
  <canvas id="canvas" onClick="playPause();"></canvas>
  <div id="info" onClick="next(); refresh();"></div>
  <div id="settings" onClick="species(); refresh();"></div>
  <div id="controls" onMouseOver="this.style.right='-45vh';">
    <h1>Primordial Particle System</h1>
    <p>by Joe Haythornthwaite & Adam Wilkinson</p>
    <p>Based on the <a href="http://zool33.uni-graz.at/artlife/PPS" target="graz">Primordial Particle System</a><br/>
      Originally developed at Graz University<br />
      by Thomas Schmickl & Martin Stefanec<br />
      <a href="https://www.youtube.com/watch?v=makaJpLvbow" target="youtube">&nbsp;»&thinsp;Watch the YouTube video&thinsp;«&nbsp;</a></p>
    <h2 onClick="link(0);">Species parameters</h2>
    <p>Alpha (intrinsic turning angle)<br />
      <input id="alpha" type="range" min="-180" max="180" step="1" onInput="change(this.id,this.value);" /><br />
      Beta (reactive turning angle)<br />
      <input id="beta" type="range" min="-90" max="90" step="1" onInput="change(this.id,this.value);" /><br />
      Gamma (step size)<br />
      <input id="gamma" type="range" min="0.005" max="0.5" step="0.005" onInput="change(this.id,this.value);" /></p>
    <h2 onClick="link(1);">Environmental controls</h2>
    <p>Number of particles (<span id="num"></span>)<br />
      <input id="number" type="range" min="100" max="10000" step="100" onInput="change(this.id,this.value);" /><br />
      Particle density (<span id="den"></span>%)<br />
      <input id="density" type="range" min="1" max="50" step="1" onInput="change(this.id,this.value);" /><br />
      Particle size<br />
      <input id="size" type="range" min="0.05" max="0.5" step="0.025" onInput="change(this.id,this.value);" /><br />
      Particle trails<br />
      <input id="trails" type="range" min="0" max="0.9" step="0.1" onInput="change(this.id,this.value);" /><br />
      Frame rate (<span id="rate"></span>fps)<br />
      <input id="framerate" type="range" min="5" max="100" step="5" onInput="change(this.id,this.value);" /><br />
      Redistribute<br />
      <input type="button" value="Random" onClick="refresh(0);" />&emsp;<input type="button" value="Centre" onClick="refresh(1);" /></p>
  </div>
</body>
</html>